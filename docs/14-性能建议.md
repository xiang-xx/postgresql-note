# 14-性能建议


## 使用 EXPLAIN

example
```sql
EXPLAIN SELECT * FROM tenk1;
                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244
```
explain 预估的数字内容
- 预估启动消耗
- 预估总消耗，消耗是根据 disk_page_red * seq_page_cost + row_scanned * cpu_tuple_cost 算出来的
- 预估 plan node 输出的 rows，并不代表扫描或处理的行
- 预估每行的 width -- bytes

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 7000;
                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)
   Filter: (unique1 < 7000)
```
Filter 代表每一行都会经过 Filter 条件的检查。

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 100;
                                  QUERY PLAN
-------------------------------------------------------------------
-----------
 Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)
   Recheck Cond: (unique1 < 100)
   ->  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04
 rows=101 width=0)
         Index Cond: (unique1 < 10
```
两步 scan：子 scan 通过索引，查询的行数比较少，父 scan 回表获取数据，数据顺序是表顺序，不是索引顺序。

```sql
EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;
                                 QUERY PLAN
-------------------------------------------------------------------
----------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1
 width=244)
   Index Cond: (unique1 = 42)
```
上面这个列子中，行的获取是通过 index 顺序，再回表查询。因为行数少，所以才使用这种方式。



## Planner 的静态统计




## 使用 JOIN 子语句控制 Planner


## 填充数据库


## 非持久化设置
